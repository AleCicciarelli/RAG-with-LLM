import os
from langchain_core.prompts import PromptTemplate
from langchain.chains import LLMChain
import json
from langchain_community.chat_models import ChatOllama
from langchain.chat_models import init_chat_model
os.environ["LANGSMITH_TRACING"] = "false" 
os.environ["LANGSMITH_API_KEY"] = "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"

if not os.environ.get("GROQ_API_KEY"):
 os.environ["GROQ_API_KEY"] = "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"

llm = ChatOllama(model="llama3:70b", temperature=0)

# LLM: Llama3-8b by Groq
#llm = init_chat_model("llama3-70b-8192", model_provider="groq", temperature = 0)

schema_path = "schemaTPCH.txt"

# Load the schema from the file
with open(schema_path, "r") as f:
    schema = f.read().strip()
# Print the schema to verify it has been loaded correctly
print(f"Schema loaded from {schema_path}:\n{schema}\n")
def generate_plan(question, schema, llm):
    """
    Generate a plan of atomic steps to answer the question based on the provided schema.
    
    Args:
        question (str): The question to be answered.
        schema (str): The database schema in a structured format.
        llm(ChatOllama): The language model to use for generating the plan.
    Returns:
        plan: A list of atomic steps to answer the question.
    """
    prompt = PromptTemplate.from_template(
        """Based on the schema below and this question: {question}, generate a plan of natural-language, atomic steps to answer the question. 
        The plan should be a list of minimum steps, each step should be a single action that can be executed to answer the question. 
        
       SCHEMA :
       {schema}
        The plan should be in the following format without any additional text or explanation:

        [
            "Step 1: <action description>",
            "Step 2: <action description>",
            ...
        ]

        """
    )

    chain = LLMChain(
        llm=llm,
        prompt=prompt
    )

    response = chain.run({
        "question": question,
        "schema": schema
    })

    try:
        response = response.strip()
        print(f"Raw response: {response}")

        # Search for the first occurrence of square brackets to extract the JSON list
        start = response.find("[")
        end = response.rfind("]")

        if start != -1 and end != -1:
            extracted = response[start:end+1]
            print(f"üì¶ Extracted list: {extracted}")
            plan = json.loads(extracted)
            print(f"‚úÖ Parsed plan with {len(plan)} steps")
        else:
            raise ValueError("No JSON list brackets found in the response.")

    except Exception as e:
        print(f"‚ö†Ô∏è Error parsing plan: {e}")
        plan = []
    max_iterations = len(plan) if isinstance(plan, list) else 1
    if not isinstance(plan, list):
        print("‚ö†Ô∏è The response is not a valid list. Using max_iterations = 1.")
    else:
        plan = [step.strip() for step in plan if isinstance(step, str) and step.strip()]
        if not plan:
            print("‚ö†Ô∏è The plan is empty after filtering. Using max_iterations = 1.")
            max_iterations = 1
        else:
            max_iterations = len(plan)
    print(f"[INFO] Generated plan with {len(plan)} steps. Setting max_iterations = {max_iterations}")
    return plan

generate_plan(question="What is the total revenue generated by each product category in the last quarter?",
              schema= schema,
                llm=llm) 
